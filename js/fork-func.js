// Generated by CoffeeScript 1.11.1
(function() {
  var CP, ForkFunc, Path, async, call, parse, pimp, ready, translate,
    slice = [].slice;

  if (module.parent) {
    CP = require('child_process');
    Path = require('path');
    ForkFunc = function() {
      var args, callback, i, opts, path;
      path = arguments[0], args = 3 <= arguments.length ? slice.call(arguments, 1, i = arguments.length - 1) : (i = 1, []), callback = arguments[i++];
      opts = parse(path);
      return call(opts.path, opts.name, args, callback, false);
    };
    async = function() {
      var args, callback, i, opts, path;
      path = arguments[0], args = 3 <= arguments.length ? slice.call(arguments, 1, i = arguments.length - 1) : (i = 1, []), callback = arguments[i++];
      opts = parse(path);
      return call(opts.path, opts.name, args, callback, true);
    };
    pimp = function(obj, nameOrPath, pathOrAsync, async) {
      var key, opts, path;
      if (async == null) {
        async = false;
      }
      if (pathOrAsync && pathOrAsync === pathOrAsync + '') {
        key = nameOrPath;
        path = pathOrAsync;
      } else {
        path = nameOrPath;
        async = pathOrAsync;
      }
      opts = parse(path);
      key = translate(key || opts.name || Path.basename(opts.path));
      obj[key] = function() {
        var args, callback, i;
        args = 2 <= arguments.length ? slice.call(arguments, 0, i = arguments.length - 1) : (i = 0, []), callback = arguments[i++];
        return call(opts.path, opts.name, args, callback, async);
      };
      return obj;
    };
    call = function(path, name, args, callback, async) {
      var cp, error, onExit, onMessage;
      try {
        cp = CP.fork(__filename, {
          stdio: 'inherit'
        });
        onMessage = function(msg) {
          callback(msg.error, msg.result);
          return null;
        };
        onExit = function() {
          cp.removeListener('message', onMessage);
          cp.removeListener('exit', onExit);
          return null;
        };
        cp.on('message', onMessage);
        cp.on('exit', onExit);
        cp.send({
          path: path,
          name: name,
          args: args,
          async: async
        });
      } catch (error1) {
        error = error1;
        callback(error, null);
      }
      return cp;
    };
    parse = function(path) {
      var args, name, stack;
      if (/^[.]?\.\//.test(path)) {
        stack = new Error().stack.split(/\r\n|\n/);
        path = Path.join(Path.dirname(/\((.*?):/.exec(stack[3])[1]), path);
      }
      name = null;
      args = /(.*)::(.*)/.exec(path);
      if (args && args.length) {
        path = args[1];
        name = args[2];
      }
      return {
        path: path,
        name: name
      };
    };
    translate = function(key) {
      key = key.replace(/(-(.))/g, function() {
        var args;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        return args[2].toUpperCase();
      });
      return key;
    };
    ForkFunc.async = async;
    ForkFunc.pimp = pimp;
    ForkFunc["default"] = ForkFunc;
    module.exports = ForkFunc;
  } else {
    call = function(msg) {
      var error, func, result;
      try {
        func = require(msg.path);
        if (msg.name) {
          func = func[msg.name];
        }
        if (msg.async) {
          msg.args.push(ready);
        }
        result = func.apply(null, msg.args);
        if (!msg.async) {
          return ready(null, result);
        }
      } catch (error1) {
        error = error1;
        return ready(error);
      }
    };
    ready = function(error, result) {
      process.removeListener('message', call);
      return process.send({
        error: error,
        result: result
      });
    };
    process.on('message', call);
  }

}).call(this);
