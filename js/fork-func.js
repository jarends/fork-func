// Generated by CoffeeScript 1.11.1
(function() {
  var CP, ForkFunc, Path, args, async, call, code, error, func, name, opts, parse, path, pimp, ready, result, sync, translate, value,
    slice = [].slice;

  if (module.parent) {
    CP = require('child_process');
    Path = require('path');
    ForkFunc = function() {
      var args, callback, i, opts, path;
      path = arguments[0], args = 3 <= arguments.length ? slice.call(arguments, 1, i = arguments.length - 1) : (i = 1, []), callback = arguments[i++];
      opts = parse(path);
      return call(opts.path, opts.name, args, callback);
    };
    async = function() {
      var args, callback, i, opts, path;
      path = arguments[0], args = 3 <= arguments.length ? slice.call(arguments, 1, i = arguments.length - 1) : (i = 1, []), callback = arguments[i++];
      opts = parse(path);
      return call(opts.path, opts.name, args, callback, true);
    };
    sync = function() {
      var args, e, error, opts, path, result;
      path = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      opts = parse(path);
      opts.args = args;
      if (typeof path === 'function') {
        opts.code = opts.path.toString();
        opts.path = null;
      }
      args = [__filename, JSON.stringify(opts)];
      try {
        result = CP.spawnSync('node', args, {
          stdio: ['pipe', 'pipe', 'inherit']
        });
        result = ((result.stdout + '').split(/\r\n|\n/)).pop();
        result = JSON.parse(result);
        error = result.error;
        if (error) {
          throw new Error('while executing forc-func.sync:\n' + error.stack);
        }
      } catch (error1) {
        e = error1;
        throw new Error('while executing forc-func.sync:\n' + error.stack);
      }
      return result.value;
    };
    pimp = function(obj, nameOrPath, pathOrAsync, async) {
      var key, opts, path;
      if (pathOrAsync && pathOrAsync === pathOrAsync + '') {
        key = nameOrPath;
        path = pathOrAsync;
      } else {
        path = nameOrPath;
        async = pathOrAsync;
      }
      opts = parse(path);
      key = translate(key || opts.name || Path.basename(opts.path));
      if (async === false) {
        obj[key] = function() {
          var args;
          args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
          return call(opts.path, opts.name, args, null, async);
        };
      } else {
        obj[key] = function() {
          var args, callback, i;
          args = 2 <= arguments.length ? slice.call(arguments, 0, i = arguments.length - 1) : (i = 0, []), callback = arguments[i++];
          return call(opts.path, opts.name, args, callback, async);
        };
      }
      return obj;
    };
    call = function(path, name, args, callback, async) {
      var code, cp, error, onError, onExit, onMessage, onStdError;
      if (async === false) {
        if (typeof path === 'string' && name) {
          path = path + '::' + name;
        }
        args.unshift(path);
        return sync.apply(null, args);
      }
      try {
        onMessage = function(msg) {
          if (msg.error) {
            msg.error = JSON.parse(msg.error);
            null;
          }
          callback(msg.error, msg.result);
          return null;
        };
        onError = function(error) {
          callback(error);
          return null;
        };
        onStdError = function(data) {
          var parsed;
          data = data.toString().split(/\r\n|\n/);
          data.splice(0, 4);
          parsed = /(.*?):\s(.*)/.exec(data[0]);
          callback({
            name: parsed[1],
            message: parsed[2],
            stack: data.join('\n')
          });
          return null;
        };
        onExit = function() {
          cp.removeListener('message', onMessage);
          cp.removeListener('error', onError);
          cp.removeListener('exit', onExit);
          cp.stderr.removeListener('data', onStdError);
          return null;
        };
        cp = CP.fork(__filename, {
          stdio: ['pipe', 'inherit', 'pipe', 'ipc']
        });
        cp.on('message', onMessage);
        cp.on('error', onError);
        cp.on('exit', onExit);
        cp.stderr.on('data', onStdError);
        if (typeof path === 'function') {
          code = path.toString();
          path = null;
        }
        cp.send({
          path: path,
          name: name,
          code: code,
          args: args,
          async: async
        });
      } catch (error1) {
        error = error1;
        callback(error, null);
      }
      return cp;
    };
    parse = function(path) {
      var args, name, stack;
      name = null;
      if (typeof path === 'function') {
        return {
          path: path,
          name: name
        };
      }
      if (/^[.]?\.\//.test(path)) {
        stack = new Error().stack.split(/\r\n|\n/);
        path = Path.join(Path.dirname(/\((.*?):/.exec(stack[3])[1]), path);
      }
      args = /(.*)::(.*)/.exec(path);
      if (args && args.length) {
        path = args[1];
        name = args[2];
      }
      return {
        path: path,
        name: name
      };
    };
    translate = function(key) {
      key = key.replace(/(-(.))/g, function() {
        var args;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        return args[2].toUpperCase();
      });
      return key;
    };
    ForkFunc.async = async;
    ForkFunc.sync = sync;
    ForkFunc.pimp = pimp;
    ForkFunc["default"] = ForkFunc;
    module.exports = ForkFunc;
  } else {
    args = process.argv;
    if (args.length === 3 && args[1] === __filename) {
      opts = JSON.parse(args[2]);
      path = opts.path;
      name = opts.name;
      args = opts.args;
      code = opts.code;
      try {
        if (code) {
          args = JSON.stringify(args);
          eval("value = (" + code + ").apply(null, " + args + ");");
        } else {
          func = require(path);
          if (name && name !== 'null') {
            func = func[name];
          }
          value = func.apply(null, args);
        }
      } catch (error1) {
        error = error1;
        error = {
          name: error.name,
          message: error.message,
          stack: error.stack
        };
      }
      result = JSON.stringify({
        error: error,
        value: value
      });
      process.stdout.write(result, 'utf8');
    } else {
      call = function(msg) {
        try {
          if (msg.code) {
            args = JSON.stringify(msg.args);
            if (msg.async) {
              args = args.slice(0, -1) + ', ' + ready.toString() + ']';
            }
            eval("result = (" + msg.code + ").apply(null, " + args + ");");
            if (!msg.async) {
              ready(null, result);
            }
          } else {
            func = require(msg.path);
            if (msg.name) {
              func = func[msg.name];
            }
            if (msg.async) {
              msg.args.push(ready);
            }
            result = func.apply(null, msg.args);
            if (!msg.async) {
              ready(null, result);
            }
          }
        } catch (error1) {
          error = error1;
          ready(JSON.stringify({
            name: error.name,
            message: error.message,
            stack: error.stack
          }));
        }
        return null;
      };
      ready = function(error, result) {
        process.removeListener('message', call);
        return process.send({
          error: error,
          result: result
        });
      };
      process.on('message', call);
    }
  }

}).call(this);
